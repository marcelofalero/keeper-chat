package sqlite_test

import (
	"database/sql"
	"keeper/server/adapters/messaging/sqlite" // Package being tested
	"keeper/server/models"
	"os"
	"sort"
	"testing"
	"time"

	_ "github.com/mattn/go-sqlite3" // SQLite driver
)

// setupTestDB creates an in-memory SQLite database for testing.
func setupTestDB(t *testing.T) *sql.DB {
	t.Helper() // Marks this function as a test helper

	// ":memory:" is a special string for in-memory SQLite database.
	// "?_foreign_keys=on" can be useful if your schema uses foreign keys.
	db, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open in-memory database: %v", err)
	}

	// Optional: Ping to ensure the connection is alive, though Open usually suffices for in-memory.
	if err := db.Ping(); err != nil {
		db.Close() // Close if ping fails
		t.Fatalf("Failed to ping in-memory database: %v", err)
	}

	return db
}

// TestMain can be used for global setup/teardown if needed,
// but for in-memory DBs, setupTestDB per test suite is often cleaner.
func TestMain(m *testing.M) {
	// Global setup here if required
	exitCode := m.Run()
	// Global teardown here if required
	os.Exit(exitCode)
}

func TestInitSchema_Messages(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := sqlite.NewSQLiteRepository(db)

	err := repo.InitSchema()
	if err != nil {
		t.Fatalf("InitSchema() failed: %v", err)
	}

	// Query sqlite_master to verify table creation
	var tableName string
	query := "SELECT name FROM sqlite_master WHERE type='table' AND name='messages';"
	err = db.QueryRow(query).Scan(&tableName)
	if err != nil {
		if err == sql.ErrNoRows {
			t.Fatal("'messages' table not found in schema after InitSchema()")
		}
		t.Fatalf("Error querying schema for messages table: %v", err)
	}
	if tableName != "messages" {
		t.Errorf("Expected table name 'messages', got '%s'", tableName)
	}

	// Verify columns (optional, but good for completeness)
	rows, err := db.Query("PRAGMA table_info(messages);")
	if err != nil {
		t.Fatalf("Failed to query table info for messages: %v", err)
	}
	defer rows.Close()

	expectedColumns := map[string]string{
		"id":        "INTEGER",
		"user":      "TEXT",
		"text":      "TEXT",
		"timestamp": "DATETIME",
	}
	foundColumns := make(map[string]string)
	for rows.Next() {
		var cid int
		var name string
		var typeName string
		var notnull int
		var dfltValue sql.NullString
		var pk int
		if err := rows.Scan(&cid, &name, &typeName, &notnull, &dfltValue, &pk); err != nil {
			t.Fatalf("Failed to scan row from table_info: %v", err)
		}
		foundColumns[name] = typeName
		// Could also check PK, NOT NULL constraints if desired
	}

	for colName, colType := range expectedColumns {
		foundType, exists := foundColumns[colName]
		if !exists {
			t.Errorf("Expected column '%s' not found", colName)
		}
		if foundType != colType {
			t.Errorf("For column '%s', expected type '%s', got '%s'", colName, colType, foundType)
		}
	}
}

func TestSaveMessage(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := sqlite.NewSQLiteRepository(db)
	if err := repo.InitSchema(); err != nil { // Ensure schema exists
		t.Fatalf("InitSchema() failed: %v", err)
	}

	// Prepare a sample message
	// Note: models.Message has an ID field. The DB generates this.
	// The SaveMessage method in the current implementation doesn't return the ID.
	// We should retrieve it from the DB to verify.
	now := time.Now().Truncate(time.Second) // Truncate for consistent time comparison with DB
	sampleMessage := models.Message{
		// ID will be auto-generated by SQLite
		User:      "TestUser",
		Text:      "Hello, SQLite!",
		Timestamp: now,
	}

	err := repo.SaveMessage(sampleMessage)
	if err != nil {
		t.Fatalf("SaveMessage() failed: %v", err)
	}

	// Query the database to verify insertion
	var (
		id        int64
		user      string
		text      string
		timestamp time.Time
	)
	// Assuming only one message is inserted for this test
	query := "SELECT id, user, text, timestamp FROM messages WHERE user = ? AND text = ?;"
	err = db.QueryRow(query, sampleMessage.User, sampleMessage.Text).Scan(&id, &user, &text, &timestamp)
	if err != nil {
		t.Fatalf("Failed to query saved message: %v", err)
	}

	if id == 0 { // SQLite auto-increment IDs are usually > 0
		t.Errorf("Expected auto-generated ID to be non-zero, got %d", id)
	}
	if user != sampleMessage.User {
		t.Errorf("Expected user '%s', got '%s'", sampleMessage.User, user)
	}
	if text != sampleMessage.Text {
		t.Errorf("Expected text '%s', got '%s'", sampleMessage.Text, text)
	}
	// For timestamp, ensure they are compared in UTC or consistent timezone
	// and handle potential precision differences if not truncating.
	if !timestamp.Equal(now) {
		t.Errorf("Expected timestamp %v, got %v", now, timestamp)
	}
}

func TestGetMessages(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := sqlite.NewSQLiteRepository(db)
	if err := repo.InitSchema(); err != nil {
		t.Fatalf("InitSchema() failed: %v", err)
	}

	// Prepare and save sample messages
	// Timestamps are crucial for verifying order
	ts1 := time.Now().Add(-2 * time.Hour).Truncate(time.Second)
	ts2 := time.Now().Add(-1 * time.Hour).Truncate(time.Second)
	ts3 := time.Now().Truncate(time.Second)

	messagesToSave := []models.Message{
		{User: "User1", Text: "Message 1", Timestamp: ts1}, // Oldest
		{User: "User2", Text: "Message 2", Timestamp: ts2},
		{User: "User1", Text: "Message 3", Timestamp: ts3}, // Newest
	}

	for _, msg := range messagesToSave {
		if err := repo.SaveMessage(msg); err != nil {
			t.Fatalf("SaveMessage() failed during setup: %v for message: %+v", err, msg)
		}
	}

	// Retrieve messages
	retrievedMessages, err := repo.GetMessages()
	if err != nil {
		t.Fatalf("GetMessages() failed: %v", err)
	}

	if len(retrievedMessages) != len(messagesToSave) {
		t.Fatalf("Expected %d messages, got %d", len(messagesToSave), len(retrievedMessages))
	}

	// Verify content and order (assuming GetMessages orders by timestamp ASC)
	// The repository GetMessages implementation uses "ORDER BY timestamp ASC"
	expectedOrder := []struct {
		User string
		Text string
		TS   time.Time
	}{
		{"User1", "Message 1", ts1},
		{"User2", "Message 2", ts2},
		{"User1", "Message 3", ts3},
	}

	for i, expected := range expectedOrder {
		actual := retrievedMessages[i]
		if actual.User != expected.User {
			t.Errorf("Message %d: Expected user '%s', got '%s'", i, expected.User, actual.User)
		}
		if actual.Text != expected.Text {
			t.Errorf("Message %d: Expected text '%s', got '%s'", i, expected.Text, actual.Text)
		}
		if !actual.Timestamp.Equal(expected.TS) {
			// The GetMessages implementation parses timestamp string from DB.
			// Need to ensure that parsing logic is robust or test data matches expected format.
			// Current GetMessages parses "2006-01-02 15:04:05" format or RFC3339.
			// SQLite stores it as DATETIME, which is usually string "YYYY-MM-DD HH:MM:SS".
			t.Errorf("Message %d: Expected timestamp %v, got %v", i, expected.TS, actual.Timestamp)
		}
		if actual.ID == 0 { // Check if ID was populated (it should be)
			t.Errorf("Message %d: Expected ID to be populated, got 0", i)
		}
	}
}

func TestGetMessages_Sorted(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := sqlite.NewSQLiteRepository(db)
	if err := repo.InitSchema(); err != nil {
		t.Fatalf("InitSchema() failed: %v", err)
	}

	// Timestamps deliberately out of order for saving
	now := time.Now().Truncate(time.Second)
	messagesToSave := []models.Message{
		{User: "UserC", Text: "Msg C - Middle", Timestamp: now.Add(-10 * time.Minute)},
		{User: "UserA", Text: "Msg A - Last", Timestamp: now},
		{User: "UserB", Text: "Msg B - First", Timestamp: now.Add(-20 * time.Minute)},
	}

	for _, msg := range messagesToSave {
		if err := repo.SaveMessage(msg); err != nil {
			t.Fatalf("SaveMessage() failed: %v for message: %+v", err, msg)
		}
	}

	retrievedMessages, err := repo.GetMessages()
	if err != nil {
		t.Fatalf("GetMessages() failed: %v", err)
	}

	if len(retrievedMessages) != len(messagesToSave) {
		t.Fatalf("Expected %d messages, got %d", len(messagesToSave), len(retrievedMessages))
	}

	// Verify that messages are sorted by timestamp (ascending)
	isSorted := sort.SliceIsSorted(retrievedMessages, func(i, j int) bool {
		return retrievedMessages[i].Timestamp.Before(retrievedMessages[j].Timestamp)
	})

	if !isSorted {
		t.Error("Retrieved messages are not sorted by timestamp ASC as expected.")
		for i, msg := range retrievedMessages {
			t.Logf("Msg %d: User: %s, Text: %s, TS: %s, ID: %d", i, msg.User, msg.Text, msg.Timestamp, msg.ID)
		}
	}

	// Additionally check the first and last element content if sorted
	if isSorted {
		if retrievedMessages[0].Text != "Msg B - First" {
			t.Errorf("Expected first message to be 'Msg B - First', got '%s'", retrievedMessages[0].Text)
		}
		if retrievedMessages[2].Text != "Msg A - Last" {
			t.Errorf("Expected last message to be 'Msg A - Last', got '%s'", retrievedMessages[2].Text)
		}
	}
}

func TestGetMessages_Empty(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := sqlite.NewSQLiteRepository(db)
	if err := repo.InitSchema(); err != nil { // Ensure schema exists
		t.Fatalf("InitSchema() failed: %v", err)
	}

	retrievedMessages, err := repo.GetMessages()
	if err != nil {
		t.Fatalf("GetMessages() failed: %v", err)
	}

	if len(retrievedMessages) != 0 {
		t.Errorf("Expected 0 messages for an empty database, got %d", len(retrievedMessages))
	}
	// Also check if the slice is nil or empty non-nil, depending on repo implementation.
	// Current GetMessages returns an empty slice, not nil.
	if retrievedMessages == nil {
		t.Error("Expected non-nil empty slice, got nil")
	}
}

// Potential further tests:
// - SaveMessage with invalid data (e.g., too long text if there were constraints)
// - Error handling in DB operations (e.g., simulate DB connection failure - harder with in-memory)
// - Concurrency tests if the repository is meant to be used concurrently (though SQLite has limitations)
// - Test timestamp parsing in GetMessages with various formats if the DB could store them differently.
