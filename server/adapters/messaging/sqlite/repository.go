package sqlite

import (
	"database/sql"
	"log"
	"time" // Included for completeness, may be used by specific timestamp logic later

	_ "github.com/mattn/go-sqlite3" // SQLite driver
	"keeper/server/core/ports"
	"keeper/server/models"
)

// Verify SQLiteRepository implements ports.MessageRepository
var _ ports.MessageRepository = (*SQLiteRepository)(nil)

// SQLiteRepository implements the ports.MessageRepository interface using SQLite.
type SQLiteRepository struct {
	db *sql.DB
}

// NewSQLiteRepository creates a new instance of SQLiteRepository.
// It takes a *sql.DB database connection as input.
func NewSQLiteRepository(db *sql.DB) *SQLiteRepository {
	return &SQLiteRepository{db: db}
}

// InitSchema creates the necessary database schema (tables) if they don't already exist.
func (s *SQLiteRepository) InitSchema() error {
	query := `
	CREATE TABLE IF NOT EXISTS messages (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		user TEXT,
		text TEXT,
		timestamp DATETIME
	);`
	_, err := s.db.Exec(query)
	if err != nil {
		log.Printf("Error initializing schema: %v", err)
		return err
	}
	log.Println("Database schema initialized successfully.")
	return nil
}

// SaveMessage saves a new message to the SQLite database.
// The ID of the message is automatically generated by the database.
func (s *SQLiteRepository) SaveMessage(msg models.Message) error {
	query := "INSERT INTO messages (user, text, timestamp) VALUES (?, ?, ?)"
	stmt, err := s.db.Prepare(query)
	if err != nil {
		log.Printf("Error preparing save message statement: %v", err)
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(msg.User, msg.Text, msg.Timestamp)
	if err != nil {
		log.Printf("Error executing save message statement: %v", err)
		return err
	}
	return nil
}

// GetMessages retrieves all messages from the SQLite database, ordered by timestamp.
func (s *SQLiteRepository) GetMessages() ([]models.Message, error) {
	query := "SELECT id, user, text, timestamp FROM messages ORDER BY timestamp ASC"
	rows, err := s.db.Query(query)
	if err != nil {
		log.Printf("Error querying messages: %v", err)
		return nil, err
	}
	defer rows.Close()

	var messages []models.Message
	for rows.Next() {
		var msg models.Message
		var timestampStr string // Read timestamp as string first
		if err := rows.Scan(&msg.ID, &msg.User, &msg.Text, &timestampStr); err != nil {
			log.Printf("Error scanning message row: %v", err)
			return nil, err
		}
		// Parse the timestamp string into time.Time
		// SQLite DATETIME is typically YYYY-MM-DD HH:MM:SS
		parsedTime, err := time.Parse("2006-01-02 15:04:05", timestampStr)
		if err != nil {
			// Attempt to parse with timezone if the first parse fails (more robust)
			parsedTime, err = time.Parse(time.RFC3339, timestampStr)
			if err != nil {
				log.Printf("Error parsing timestamp string '%s': %v", timestampStr, err)
				// Decide how to handle: skip this message, return error, or use zero time
				// For now, continue with zero time for timestamp if parsing fails.
				// msg.Timestamp = time.Time{} // Or return the error
			}
		}
		msg.Timestamp = parsedTime
		messages = append(messages, msg)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating message rows: %v", err)
		return nil, err
	}

	return messages, nil
}
