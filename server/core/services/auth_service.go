package services

import (
	"errors"
	"log"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
	"keeper/server/core/ports"
	"keeper/server/models"
)

// jwtExpiration defines the duration for which JWT tokens are valid.
const jwtExpiration = time.Hour * 72

// ErrUserAlreadyExists is returned when trying to register a user that already exists.
var ErrUserAlreadyExists = errors.New("user already exists")

// ErrUserNotFound is returned when a user is not found.
var ErrUserNotFound = errors.New("user not found")

// ErrInvalidCredentials is returned for login attempts with wrong username or password.
var ErrInvalidCredentials = errors.New("invalid username or password")

// ErrInvalidToken is returned when a JWT token is invalid or expired.
var ErrInvalidToken = errors.New("invalid or expired token")

// JwtCustomClaims defines the custom claims for JWT.
type JwtCustomClaims struct {
	Username string `json:"username"`
	UserID   int64  `json:"user_id"`
	jwt.RegisteredClaims
}

// AuthServiceImpl implements the ports.AuthService interface.
type AuthServiceImpl struct {
	userRepo  ports.UserRepository
	jwtSecret []byte
}

// Verify AuthServiceImpl implements ports.AuthService
var _ ports.AuthService = (*AuthServiceImpl)(nil)

// NewAuthService creates a new instance of AuthServiceImpl.
func NewAuthService(userRepo ports.UserRepository, jwtSecret string) *AuthServiceImpl {
	return &AuthServiceImpl{
		userRepo:  userRepo,
		jwtSecret: []byte(jwtSecret),
	}
}

// Register creates a new user account.
func (s *AuthServiceImpl) Register(username, password string) (*models.User, error) {
	existingUser, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		// Log the actual error for debugging, but return a generic one to the client
		log.Printf("Error checking for existing user '%s': %v", username, err)
		return nil, errors.New("could not verify user existence")
	}
	if existingUser != nil {
		return nil, ErrUserAlreadyExists
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error hashing password for user '%s': %v", username, err)
		return nil, errors.New("failed to process registration")
	}

	newUser := models.User{
		Username:     username,
		PasswordHash: string(hashedPassword),
	}

	err = s.userRepo.CreateUser(newUser)
	if err != nil {
		log.Printf("Error creating user '%s': %v", username, err)
		return nil, errors.New("failed to save user")
	}

	// It's good practice to fetch the user again to get the ID generated by the DB
	// and to avoid returning the password hash.
	createdUser, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		log.Printf("Error fetching created user '%s': %v", username, err)
		return nil, errors.New("failed to retrieve user details after creation")
	}
	if createdUser == nil { // Should ideally not happen if CreateUser was successful
		log.Printf("User '%s' not found after creation", username)
		return nil, ErrUserNotFound
	}
	
	// Clear password hash before returning to client
	createdUser.PasswordHash = "" 
	return createdUser, nil
}

// Login authenticates a user and returns a JWT token.
func (s *AuthServiceImpl) Login(username, password string) (string, error) {
	user, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		log.Printf("Error fetching user '%s' during login: %v", username, err)
		return "", ErrInvalidCredentials // Generic error for security
	}
	if user == nil {
		return "", ErrInvalidCredentials // User not found
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
	if err != nil {
		// Password mismatch or other bcrypt error
		return "", ErrInvalidCredentials
	}

	// Create claims
	claims := JwtCustomClaims{
		Username: user.Username,
		UserID:   user.ID,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(jwtExpiration)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			Issuer:    "keeper-server", // Optional: identifies the issuer
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(s.jwtSecret)
	if err != nil {
		log.Printf("Error signing token for user '%s': %v", username, err)
		return "", errors.New("could not generate token")
	}

	return tokenString, nil
}

// ValidateToken checks the validity of a JWT token and returns the associated user.
func (s *AuthServiceImpl) ValidateToken(tokenString string) (*models.User, error) {
	claims := &JwtCustomClaims{}

	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		// Check the signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected signing method")
		}
		return s.jwtSecret, nil
	})

	if err != nil {
		log.Printf("Error parsing token: %v", err)
		if errors.Is(err, jwt.ErrTokenExpired) || errors.Is(err, jwt.ErrTokenNotValidYet) {
			return nil, ErrInvalidToken
		}
		return nil, errors.New("could not parse token")
	}

	if !token.Valid {
		return nil, ErrInvalidToken
	}

	// Token is valid, claims are populated. Fetch user for current details.
	user, err := s.userRepo.GetUserByID(claims.UserID)
	if err != nil {
		log.Printf("Error fetching user by ID '%d' after token validation: %v", claims.UserID, err)
		return nil, errors.New("error verifying token holder")
	}
	if user == nil {
		return nil, ErrUserNotFound // User associated with token no longer exists
	}

	// Clear password hash before returning
	user.PasswordHash = ""
	return user, nil
}
