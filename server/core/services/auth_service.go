package services

import (
	"errors"
	"log"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
	"keeper/server/core/ports"
	"keeper/server/models"
)

// jwtExpiration defines the duration for which JWT tokens are valid.
// This constant is no longer used for token generation in this service but kept for context.
const jwtExpiration = time.Hour * 72

// HardcodedUserAuthToken is used for WebSocket validation and as the token value in login responses.
const HardcodedUserAuthToken = "HARDCODED_TOKEN_FOR_NOW"

// ErrUserAlreadyExists is returned when trying to register a user that already exists.
var ErrUserAlreadyExists = errors.New("user already exists")

// ErrUserNotFound is returned when a user is not found.
var ErrUserNotFound = errors.New("user not found")

// ErrInvalidCredentials is returned for login attempts with wrong username or password.
var ErrInvalidCredentials = errors.New("invalid username or password")

// ErrInvalidToken is returned when a JWT token is invalid or expired.
var ErrInvalidToken = errors.New("invalid or expired token")

// JwtCustomClaims defines the custom claims for JWT.
type JwtCustomClaims struct {
	Username string `json:"username"`
	UserID   int64  `json:"user_id"`
	jwt.RegisteredClaims
}

// AuthServiceImpl implements the ports.AuthService interface.
type AuthServiceImpl struct {
	userRepo   ports.UserRepository
	jwtSecret  []byte
	bcryptCost int // Added bcrypt cost
}

// Verify AuthServiceImpl implements ports.AuthService
var _ ports.AuthService = (*AuthServiceImpl)(nil)

// NewAuthService creates a new instance of AuthServiceImpl.
func NewAuthService(userRepo ports.UserRepository, jwtSecret string) *AuthServiceImpl {
	return &AuthServiceImpl{
		userRepo:   userRepo,
		jwtSecret:  []byte(jwtSecret),
		bcryptCost: bcrypt.DefaultCost, // Initialize bcryptCost
	}
}

// HashPassword generates a bcrypt hash for the given password.
func (s *AuthServiceImpl) HashPassword(password string) (string, error) {
	hashedPasswordBytes, err := bcrypt.GenerateFromPassword([]byte(password), s.bcryptCost)
	if err != nil {
		log.Printf("Error hashing password: %v", err) // Log the error
		return "", err
	}
	return string(hashedPasswordBytes), nil
}

// Register creates a new user account.
func (s *AuthServiceImpl) Register(username, password string) (*models.User, error) {
	existingUser, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		// Log the actual error for debugging, but return a generic one to the client
		log.Printf("Error checking for existing user '%s': %v", username, err)
		return nil, errors.New("could not verify user existence")
	}
	if existingUser != nil {
		return nil, ErrUserAlreadyExists
	}

	// Use s.HashPassword which uses s.bcryptCost
	hashedPasswordString, err := s.HashPassword(password)
	if err != nil {
		// HashPassword already logs the error, but we can add context
		log.Printf("Error hashing password for user '%s' during registration: %v", username, err)
		return nil, errors.New("failed to process registration")
	}

	newUser := models.User{
		Username:     username,
		PasswordHash: hashedPasswordString, // Use the string from HashPassword
	}

	err = s.userRepo.CreateUser(newUser)
	if err != nil {
		log.Printf("Error creating user '%s': %v", username, err)
		return nil, errors.New("failed to save user")
	}

	// It's good practice to fetch the user again to get the ID generated by the DB
	// and to avoid returning the password hash.
	createdUser, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		log.Printf("Error fetching created user '%s': %v", username, err)
		return nil, errors.New("failed to retrieve user details after creation")
	}
	if createdUser == nil { // Should ideally not happen if CreateUser was successful
		log.Printf("User '%s' not found after creation", username)
		return nil, ErrUserNotFound
	}
	
	// Clear password hash before returning to client
	createdUser.PasswordHash = "" 
	return createdUser, nil
}

// VerifyUserCredentials checks if the provided username and password match a stored user.
// It returns the user model (without password hash) on success, or an error on failure.
func (s *AuthServiceImpl) VerifyUserCredentials(username, password string) (*models.User, error) {
	user, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		// Log specific error, but return generic error to client
		log.Printf("Error fetching user '%s' during credential verification: %v", username, err)
		return nil, ErrInvalidCredentials
	}
	if user == nil {
		log.Printf("User '%s' not found during credential verification.", username)
		return nil, ErrInvalidCredentials // User not found
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
	if err != nil {
		// Password mismatch or other bcrypt error
		log.Printf("Password mismatch for user '%s'.", username)
		return nil, ErrInvalidCredentials
	}

	// Credentials are valid.
	log.Printf("Credentials verified for user '%s'.", username)
	// Clear password hash before returning user model
	user.PasswordHash = ""
	return user, nil
}

// ValidateToken checks the validity of the hardcoded token.
func (s *AuthServiceImpl) ValidateToken(tokenString string) (*models.User, error) {
	if tokenString == HardcodedUserAuthToken {
		// For WebSocket connections, a generic user model is sufficient.
		log.Printf("Token '%s' validated successfully (hardcoded match).", tokenString)
		return &models.User{ID: 1, Username: "WebSocketUser"}, nil // Placeholder user
	}

	log.Printf("Token validation failed for token: '%s'", tokenString)
	return nil, ErrInvalidToken
}
